// 1. Хотим иметь метод для стох. процесса. В нем должно быть at least 2 функции – мю и sigma. 
// 2. Хотим иметь метод монте-карло. Есть диффьюжен. Для одномерного случая нам еще на вход нужна начальная точка процесса (1) и еще шаг вычисления. 
// 	Что мы дальше делаем? Для каждого пути получаем конечную точку. Промежуточные значения мы можем как сохранять, так и не сохранять. 
// Мы хотим сразу генерировать не один путь, а N путей, так как туда можно сразу заложить параметризацию.
// Output'ом этого метода является массив, который содержит N финальных точек. 
// Он передается функции, вызвавшей метод Монте-Карло, и она уже знает, что с этими путями делать. Построить плотность и т.п.


// В параллельных секциях никаких ответвлений лучше не делать. Хотим, чтобы в каждой секции просто ровно отрабатывал генеративный цикл. 


// Какие у нас ограничения по памяти? Для решения прайсинг задач, абсолютный минимум реализации по количеству путей:
// Std. параметра убывает как 1/sqrt(n).
// В финансовой математике есть понятие стандартной точности – 1 basis point (=== 10^(-5) - 10^(-4), не хуже)
// Это означает, что у нас будет 10^4 - 10^8 путей, чтобы получить хорошую статистическую сходимость к МО.

// Какова максимальная длина пути (например, при оценке опциона). Допустим, максимум 1 год (T = 1 year). Упарываться сильнее не будем.
// А с какой частотой будем генерировать элементы этого пути? Тут может быть все что угодно, от мс до года. 


// Посмотрим на инструмент USD/RUB, на MOEX. Мы обсуждали, что стох. эффекты не надо применять там, где начинаются микроструктурные эффекты. То есть там, где включается bid-ask spread.
// bid-ask spread -- это 0.015Rub. Какому временному интервалу он соответствует? На этот вопрос помогает ответить sigma * sqrt(tau). 
// Потому что это и есть характеристическое движение за время tau. 
// bid-ask spread = 0.015/75 = sigma*sqrt(tau) (где 75 - тек. цена). Сигма - волатильность в годах, величина порядка DS/S. Sigma ~~ 0.15. 
// 1/750 = sqrt(tau), tau = 1/750^2 =~ 1min.  => Нам не нужен шаг < 1min, иначе микро эффекты. 
// Стандартный timestamp – 1 минута или 5 минут. => tau = 1/5 min

// В самом худшем случае, если моделируем на год, 5 min/наблюдение, то у нас 365*1440(min) / 5 = 105 120 (- длина пути) ~10^5
 
// Итого получается 10^4 * 10^5 = 10^9 entries (длина * кол-во путей). 
// Размер одного entrie - 8 bytes (double, bite). 10^9 - это примерно 8 гб, 10^13 - 1 террабайт, уже не реалистично.
// Граф. карта, если на ней моделируем, типично имеет 4-6 ГБ памяти. 8 - вряд ли. То есть мы уже на пределе. 

//  В большинстве случаев нам это и не понадобится. Нам не нужно будет хранить пути, понадобятся только финальные точки. Но проблема в другом:
// Нам понадобится вычислять пути параллельно, они должны занимать параллельные участки памяти, чтобы не происходило clashing overwriting. Короче, то на то и выйдет.
// Вывод – если simulation на body, то не будем 5 минут использовать, будем 30. Объем уменьшается в 5 раз. 

// Итого – 1 min - нет. 5 min - мб. 30 min - мб.


// То, что мы сейчас обсуждали – Monte-Carlo Engine.


// Далее - Diffusion. 
// Еще один неприятный проект – выполнение кода на GPU, как раз таки плохо работает и плохо поддерживает парадингму наследования в C++. 
// Все dispatch операции даже если поддерживаются, то очень сильно ухудшают GPU performance. То есть, если вычисляем на GPU, то никаких ветвлений не должно быть.
// Если Monte-Carlo Engine выполняется на GPU и оттуда вызывает функции, которые дают нам кэф. процесса, 
// а эти функции вирутальны, за счет того что мы реализовали их методом наследния. Эти методы невозможно вызвать из GPU-лупа. 
// А если так, то этот дизайн нам в принципе не подходит из-за своей низкой эффективностию

// Cost вызова виртуальных методов в C++:
// У нас есть pointer на объект и при вызове метода происходит анализ таблицы виртуальных функций, которая уже содержится в derived metode. 
// То есть перескок (1 interaction) + нахождение по хэшу в таблице + юзание метода (~5 машинных команд.)
// Пять команд тратим, почему это плохо? Ведь 5 – не очень много:
// 1) Не поддерживается на GPU. 2) 5 – не очень много, но мы много раз делаем. Относительный Cost этих операций. Например, вызывая функцию mu мы вместо одного умножения (mu*S_t) делаем 5 операций. Пятикратный overhead. 
// 3) Если бы можно было обойтись без вызова функции, то вообще не было бы никакого вызова, это операция была бы зашита внутрь кода. Виртуальные функции препятствуют инлайнингу. В отличие от концепции 80-90-х годов, ООП с динамическим dispatching – это плохо, по крайней мере во внутреннем high-perfomance loop'e. 

// Что еще плохо?
// Предположим, у нас есть вектор. Нужно сделать операцию по 3-4 циклам вложенным. Это многократный overhead доступа к элементу вектора. 
// Перед входом в вектор мы получаем raw pointer (низкоуровневый pointer) на начальный уровень этого вектора. И потом уже мы никакую векторную арифметику не используем, только pointer(?) арифметику, которая командно проще.

// Даже на обыкновенном CPU использование векторных операций внутри больших циклов приводит к очень большому overhead. 



// Если не можем в наследование и виртуальные методы, что мы используем? Темплейтезирование?

// Помимо Monte-Carlo еще будут сеточные мат. методы. 

// Самая первая строчка – защита от повторого include. 
// Современный подход: одна строчка вместо старой допотопной конструкции.
// #pragma once

// Мы будем писать темплейтный код. Обычно это называется headers-only style. 

// У нас есть какой-то класс, например, diffusionGBM {}. В нем задаем методы mu(...) и sigma(...). Если методы/классы достаточно большие, то часто бывает полезно дать просто прототипы этих классов и сделать отдельные чето-там пипи для них.

// оператор ? в C++: 
#pragma once
#include <cmath>
#include <stdexcept>
namespace SiriusFM {
	// что делать с трендами? будем считать пока, что тренды более сложные, чем линейные, особого смысла не имеют. Тренды во всех этих случаях будут просто линейными. А волатильности будут разными.

	class DiffusionGBM {
	private:
		double const m_mu;
		double const m_sigma;

	public:
		double mu (double s, double t) {
			return m_mu * s;
		};

		double sigma (double s, double t) {
			return m_sigma * s;
		};

		DiffusionGBM (double a_mu, double a_sigma):
		m_mu(a_mu)
		m_sigma(a_sigma)
		{
			if (m_sigma < 0) throw std::invalid_argument("Invalid Sigma, Diffusion GBM")
		}
	}

	

	
	class DiffusionCEV {
		// beta >= 0
		// sigma > 0
	private:
		double const m_mu;
		double const m_sigma;
		double const m_beta;
	
	public:
		double mu (double s, double t) const {
			return m_mu * s;
		};

		double sigma (double s, double t) const {
			return m_sigma * pow(s, m_beta) ;
		};

		DiffusionCEV(double a_mu, double a_sigma, double a_beta):
		m_mu(a_mu)
		m_sigma(a_sigma)
		m_beta(a_beta)

		{
			if (a_sigma < 0 ) throw std::invalid_argument("Invalid sigma, DiffusionCEV")
			else if (a_beta <0) throw std::invalid_argument("Invalid beta, DiffusionCEV")
		}


	}

	class DiffusionOU {
		//mu = kappa * (theta - s)
		// sigma - default
	private:
		double const m_mu;
		double const m_sigma;
		double const m_theta;
		double const m_kappa;
	
	public:
		double mu (double s, double t) const {
			return m_mu * (m_theta - s);
		};

		double sigma (double s, double t) const {
			return m_sigma * s;
		};

		DiffusionOU (double a_mu, double a_sigma, double a_theta, double a_kappa):
			m_mu(a_mu)
			m_sigma(a_sigma)
			m_theta(a_theta)
			m_kappa(a_kappa)
			{
				if (a_sigma < 0) throw std::invalid_argument("Invalid sigma, DiffusionOU")  
				else if (a_kappa < 0) throw std::invalid_argument("Invalid sigma, DiffusionOU")  	
			}
	}

	class DiffusionLipton {
		private:
			
			double const m_mu;
			double const m_sigma_0;
			double const m_sigma_1;
			double const m_sigma_2;
		
		public:
			
			double mu (double s, double t) const {
			return m_mu * s;
			};

			double sigma (double s, double t) const {
			return m_sigma_0 + m_sigma_1 * s + m_sigma_2 * pow(S,2);
			};

			DiffusionLipton (double a_mu, double a_sigma_0, double a_sigma_1, double a_sigma_2):  
			m_mu(a_mu) 
			m_sigma_0(a_sigma_0)  
			m_sigma_1(a_sigma_1)
			m_sigma_2(a_sigma_2)
			{
				if ( m_sigma_0 >= 0 && m_sigma_2 >= 0 &&  (pow(m_sigma_1,2) - 4 * m_sigma_0 * m_sigma_2) < 0 ) ;
				else throw std::invalid_argument("Invalid sigmas combination, DiffusionLipton") 
			}

	}
	

	class DiffusionCIR {
		// тут theta >0, тренд такой же, + старые constraints
		private:
			double const m_mu;
			double const m_sigma;
			double const m_theta;
			double const m_kappa;
		public:
			double mu (double s, double t) const {
			return m_mu * (m_theta - s);
			};

			double sigma (double s, double t) const {
			return m_sigma * sqrt(s);
			};

			DiffusionCIR (double a_mu, double a_sigma, double a_theta, double a_kappa):
			m_mu(a_mu)
			m_sigma(a_sigma)
			m_theta(a_sigma)
			m_kappa(a_kappa)
			{

				if (a_sigma < 0) throw std::invalid_argument("Invalid sigma, DiffusionOU")  
				else if (a_kappa < 0) throw std::invalid_argument("Invalid kappa, DiffusionOU")
				else if (a_theta <0) throw std::invalid_argument("Invalid theta, DiffusionOU")
			}

	}

}

 